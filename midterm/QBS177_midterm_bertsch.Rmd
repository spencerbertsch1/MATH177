---
title: "Midterm - QBS 177"
output: html_notebook
---

Spencer Bertsch  
Feb. 2022

------------

Some helpful commands:  
* Insert a new code chunk: *Cmd+Option+I*  
* Run a code cell: *Cmd+Shift+Enter*  
* Preview the notebook HTML file: *Cmd+Shift+K*  

**OPEN QUESTIONS:**
1. Do we need to fill the NAs in the SNP data for question 1? The code works just fine if we don't fill the NAs, but maybe we should fill with the mean value like we did in the homework? 


### Imports 
```{r}
library(glue)
library(qqman)
```

First we need to change our current working directory to the correct directory for Assignment 3
```{r}
setwd('/Users/spencerbertsch/Desktop/dev/phd_courses/MATH177/midterm')
getwd()
```


# Question 1
### Import the raw data 
Here we load the data that contains all of the SNPs so we can see which are the top five SNPs that have the strongest association based on their p-values. We learned in assignment 4 and lab 5 that the lowest p-values designate the SNPs that have the strongest assosiation with a response variable. 
```{r}
load('dbp.Rdata')
```

Before we can progress with question 1 (a), we need to do a few things. 
1. We need to fill the NA values in our SNPs
2. We need to alter the data type of our SNPs from factor variables [2, 3, 4] to numeric variables [0, 1, 2].


```{r}
# lets isolate the columns we need for the problem 
snp.data = dbp[,c("affection", "sex", "age", "rs1101", "rs1102", "rs1103", "rs1104", "rs1105", "rs1106", "rs1107", "rs1108", "rs1109", "rs1110", "rs1111", "rs1112", "rs1113", "rs1114", "rs1115", "rs1116", "rs1117", "rs1118", "rs1119", "rs1120")]

# convert all the SNP column to numeric and adjust them to the proper range
for (i in 1:20){
  snp.data[, (i+3)] <- as.numeric(snp.data[, (i+3)]) - 1
}

print('Summary after all the SNP variables were changed to numeric variables:')
summary(snp.data)
```
And indeed we can see that we were successful in converting all the SNPs to numeric dtypes. 

# Question: Do we need to deal with NULLs here? 

Here we examine the mean values of the columns. If the mean is NULL, that means there are NULL values in the dataframe that we need to fill with a method such as forward filling or mean value replacement.
```{r}
SNPs <- c("rs1101", "rs1102", "rs1103", "rs1104", "rs1105", "rs1106", "rs1107", "rs1108", "rs1109", "rs1110", "rs1111", "rs1112", "rs1113", "rs1114", "rs1115", "rs1116", "rs1117", "rs1118", "rs1119", "rs1120")
mu = colMeans(snp.data[, SNPs])
print(mu[0:10])
```
And we can see that some of our SNP columns contain null values! So we can simply mean fill or forward fill these values and move on. 

## TODO mean fill or forward fill the NAs
```{r}
# TODO fill NAs
```


### Question 1(a):
Here we want to use a for loop to iterate over all of the SNPs in our data set. Here we want to iterate from the 9th column to the 28th column to capture all the SNPs. That way we will capture each of the 20 SNPs in the data set. 
```{r}
pvalue <- 0

for (i in 1:20){

  # first we need to fit the logistic regression model on the SNP, adjusting for the age and sex of the patient 
  result.adj <- glm(affection ~ sex + age + snp.data[,(i+3)], family=binomial("logit"), data=snp.data)
  
  # next we grab the corresponding p-value and store it outside the loop
  pvalue[i] <- summary(result.adj)$coef[4,4] # TODO <-- double check this p-value is right, we want the one corresponding to the SNP, correct? I think that's correct. 
}

pvalue[0:10]

p_value_df <- data.frame(SNP = SNPs, p_value = pvalue)
p_value_df <- p_value_df[order(p_value_df$p_value, decreasing=FALSE), ]
head(p_value_df, 5)
```
#### 1 (a) answer: 
Here we can see that the SNPs with the strongest association (lowest p-values) are:  
1. rs1112  
2. rs1115  
3. rs1117  
4. rs1119  
5. rs1113  

### Question 1(b):

Now that we trained our logistic regression model and got the associated p-values, we need to train a linear regression model and get the p-values there as well. 

Let's fill the NAs here: (OPTIONAL - do we need to fill the NAs??)
```{r}
# for (i in 1:20){
#   snp.data[is.na(snp.data[,(i+3)]), (i+3)] <- round(mean(snp.data[,(i+3)], na.rm = TRUE))
# }
# sum(is.na(snp.data))
```

Now that we've filled the NAs with the mean from each SNP, we can train our linear regression models and find the associations between each SNP and the afection, adjusting for age and sex. 

Let's also change the response variable from a factor to a numeric response! We need to do this for our linear regression model which predicts a continuous variable - not a factor variable. 
```{r}
snp.data$affection <- as.numeric(snp.data$affection)
```


```{r}
pvalue <- 0

for (i in 1:20){

  # first we need to fit the linear regression model on the SNP, adjusting for the age and sex of the patient
  fit <- lm(affection ~ sex + age + snp.data[,(i+3)], data=snp.data)
  
  # next we grab the corresponding p-value and store it outside the loop
  pvalue[i] <- summary(fit)$coef[4,4]
}

pvalue[0:10]

p_value_df <- data.frame(SNP = SNPs, p_value = pvalue)
p_value_df <- p_value_df[order(p_value_df$p_value, decreasing=FALSE), ]
head(p_value_df, 10)
```

#### 1 (b) answer: 
Here we can see that the SNPs with the strongest association (lowest p-values) are:  
1. rs1112  
2. rs1115  
3. rs1117  
4. rs1119  
5. rs1113  
6. rs1118  
7. rs1120  
8. rs1104  
9. rs1107  
10. rs1114  

### Question 1(c):

Before we begin with Question 1 (c), we need to convert the numerical variable back to a (binary) factor variable so that our logistic regression model can use it as the response variable. 
```{r}
snp.data$affection <- as.factor(snp.data$affection)
```

We need a helper function that takes an r data frame and returns the coordinates of the smallest 10 values in the data frame in order. 
```{r}



get_indices_smallest_values <- function(matrix) {
  # This helper function returns the [row, col] coordinates of the smallest values in the matrix in order 
  # return type: list = [[row1, col1], [row2, col2], ..., [row10, col10]]

  SNPs_1 <- 0
  SNPs_2 <- 0
  p_vals <- 0
  
  for (i in 1:10){
  
    # stores indexes of min value
    min = which(matrix == min(matrix), arr.ind = TRUE)  
    print(paste("Minimum value: ", matrix[min]))
    print(min)
    
    # get the SNPs and the corresponding p-value
    index_1 <- as.integer(min[1,1])
    index_2 <- as.integer(min[1,2])
    snp1 <- SNPs[index_1]
    snp2 <- SNPs[index_2]
    p_val <- pvalue_mat[index_1, index_2]
  
    # save that data outside the loop 
    SNPs_1[i] <- snp1
    SNPs_2[i] <- snp2
    p_vals[i] <- p_val
    
    # set the two values of the old smallest value to 1 and continue 
    
  }
  
  # create a data frame out of the three lists that store the results 
  
  # return the data frame 
  return(min)
}
```


Here we want to find the p-values for the strongest SNP-SNP interactions in our logistic regression model, still adjusting for age and sex of the subject. 
```{r}
pvalue <- 0

# here we can initialize an empty matrix with 400 elements, each representing a p-value for the LR models we will train below
pvalue_mat <- setNames(data.frame(matrix(ncol = 20, nrow = 20)), SNPs)
rownames(pvalue_mat) <- SNPs


# in our outer for loop we iterate over the SNPs
for (i in 1:20){

  # Our inner loop also happens to iterate over the SNPs
  for (j in 1:20){
    
    # first we need to fit the logistic regression model on the SNP, adjusting for the age and sex of the patient
    result.adj <- glm(affection ~ sex + age + snp.data[,(i+3)]:snp.data[,(j+3)], family=binomial("logit"), data=snp.data)
    
    # next we grab the corresponding p-value and store it outside the loop
    pvalue_mat[i,j] <- summary(result.adj)$coef[4,4] 
  }
}

# pvalue[0:10]

# p_value_df <- data.frame(SNP = SNPs, p_value = pvalue)
# p_value_df <- p_value_df[order(p_value_df$p_value, decreasing=FALSE), ]
# head(p_value_df, 5)
```


### Some test code 
```{r}
min <- get_indices_smallest_values(matrix=pvalue_mat)

index_1 <- as.integer(min[1,1])
index_2 <- as.integer(min[1,2])
snp1 <- SNPs[index_1]
snp2 <- SNPs[index_2]
p_val <- pvalue_mat[index_1, index_2]
```



